{"version":3,"file":"dataTables.colReorder.min.js","sources":["../../src/libraries/dataTables.colReorder.js"],"sourcesContent":["/* eslint-disable */\n/*! ColReorder 2.0.4\n * © SpryMedia Ltd - datatables.net/license\n */\n\n(function( factory ){\n\tif ( typeof define === 'function' && define.amd ) {\n\t\t// AMD\n\t\tdefine( ['jquery', 'mod_interactivevideo/libraries/datatables'], function ( $ ) {\n\t\t\treturn factory( $, window, document );\n\t\t} );\n\t}\n\telse if ( typeof exports === 'object' ) {\n\t\t// CommonJS\n\t\tvar jq = require('jquery');\n\t\tvar cjsRequires = function (root, $) {\n\t\t\tif ( ! $.fn.dataTable ) {\n\t\t\t\trequire('mod_interactivevideo/libraries/datatables')(root, $);\n\t\t\t}\n\t\t};\n\n\t\tif (typeof window === 'undefined') {\n\t\t\tmodule.exports = function (root, $) {\n\t\t\t\tif ( ! root ) {\n\t\t\t\t\t// CommonJS environments without a window global must pass a\n\t\t\t\t\t// root. This will give an error otherwise\n\t\t\t\t\troot = window;\n\t\t\t\t}\n\n\t\t\t\tif ( ! $ ) {\n\t\t\t\t\t$ = jq( root );\n\t\t\t\t}\n\n\t\t\t\tcjsRequires( root, $ );\n\t\t\t\treturn factory( $, root, root.document );\n\t\t\t};\n\t\t}\n\t\telse {\n\t\t\tcjsRequires( window, jq );\n\t\t\tmodule.exports = factory( jq, window, window.document );\n\t\t}\n\t}\n\telse {\n\t\t// Browser\n\t\tfactory( jQuery, window, document );\n\t}\n}(function( $, window, document ) {\n'use strict';\nvar DataTable = $.fn.dataTable;\n\n\n/**\n * Mutate an array, moving a set of elements into a new index position\n *\n * @param arr Array to modify\n * @param from Start move index\n * @param count Number of elements to move\n * @param to Index where the start element will move to\n */\nfunction arrayMove(arr, from, count, to) {\n    var movers = arr.splice(from, count);\n    // Add delete and start to the array, so we can use it for the `apply`\n    movers.unshift(0); // splice delete param\n    movers.unshift(to < from ? to : to - count + 1); // splice start param\n    arr.splice.apply(arr, movers);\n}\n/**\n * Run finishing activities after one or more columns have been reordered.\n *\n * @param dt DataTable being operated on - must be a single table instance\n */\nfunction finalise(dt) {\n    // Cache invalidation. Always read from the data object rather\n    // than reading back from the DOM since it could have been\n    // changed by a renderer\n    dt.rows().invalidate('data');\n    // Redraw the header / footer. Its a little bit of a hack this, as DT\n    // doesn't expose the header draw as an API method. It calls state\n    // saving, so we don't need to here.\n    dt.column(0).visible(dt.column(0).visible());\n    dt.columns.adjust();\n    // Fire an event so other plug-ins can update\n    var order = dt.colReorder.order();\n    dt.trigger('columns-reordered', [\n        {\n            order: order,\n            mapping: invertKeyValues(order)\n        }\n    ]);\n}\n/**\n * Get the original indexes in their current order\n *\n * @param dt DataTable being operated on - must be a single table instance\n * @returns Original indexes in current order\n */\nfunction getOrder(dt) {\n    return dt.settings()[0].aoColumns.map(function (col) {\n        return col._crOriginalIdx;\n    });\n}\n/**\n * Manipulate a header / footer array in DataTables settings to reorder\n * the columns.\n */\nfunction headerUpdate(structure, map, from, to) {\n    var done = [];\n    for (var i = 0; i < structure.length; i++) {\n        var headerRow = structure[i];\n        arrayMove(headerRow, from[0], from.length, to);\n        for (var j = 0; j < headerRow.length; j++) {\n            var cell = headerRow[j].cell;\n            // Only work on a DOM element once, otherwise we risk remapping a\n            // remapped value (etc).\n            if (done.includes(cell)) {\n                continue;\n            }\n            var indexes = cell.getAttribute('data-dt-column').split(',');\n            var mapped = indexes\n                .map(function (idx) {\n                return map[idx];\n            })\n                .join(',');\n            // Update data attributes for the new column position\n            cell.setAttribute('data-dt-column', mapped);\n            done.push(cell);\n        }\n    }\n}\n/**\n * Setup for ColReorder API operations\n *\n * @param dt DataTable(s) being operated on - might have multiple tables!\n */\nfunction init(api) {\n    // Assign the original column index to a parameter that we can lookup.\n    // On the first pass (i.e. when the parameter hasn't yet been set), the\n    // index order will be the original order, so this is quite a simple\n    // assignment.\n    api.columns().iterator('column', function (s, idx) {\n        var columns = s.aoColumns;\n        if (columns[idx]._crOriginalIdx === undefined) {\n            columns[idx]._crOriginalIdx = idx;\n        }\n    });\n}\n/**\n * Switch the key value pairing of an index array to be value key (i.e. the old value is now the\n * key). For example consider [ 2, 0, 1 ] this would be returned as [ 1, 2, 0 ].\n *\n *  @param   array arr Array to switch around\n */\nfunction invertKeyValues(arr) {\n    var result = [];\n    for (var i = 0; i < arr.length; i++) {\n        result[arr[i]] = i;\n    }\n    return result;\n}\n/**\n * Move one or more columns from one index to another.\n *\n * This method has a lot of knowledge about how DataTables works internally.\n * If DataTables changes how it handles cells, columns, etc, then this\n * method would need to be updated accordingly.\n *\n * @param dt DataTable being operated on - must be a single table instance\n * @param from Column indexes to move\n * @param to Destination index (starting if multiple)\n */\nfunction move(dt, from, to) {\n    var i, j;\n    var settings = dt.settings()[0];\n    var columns = settings.aoColumns;\n    var newOrder = columns.map(function (col, idx) {\n        return idx;\n    });\n    // The to column in already inside the from column(s) (might be the same)\n    // no change required\n    if (from.includes(to)) {\n        return;\n    }\n    // A reverse index array so we can look up new indexes from old\n    arrayMove(newOrder, from[0], from.length, to);\n    var reverseIndexes = invertKeyValues(newOrder);\n    // Main column\n    arrayMove(columns, from[0], from.length, to);\n    // Per row manipulations\n    for (i = 0; i < settings.aoData.length; i++) {\n        var data = settings.aoData[i];\n        // Allow for sparse array\n        if (!data) {\n            continue;\n        }\n        var cells = data.anCells;\n        // Not yet rendered\n        if (!cells) {\n            continue;\n        }\n        // Array of cells\n        arrayMove(cells, from[0], from.length, to);\n        for (j = 0; j < cells.length; j++) {\n            // Reinsert into the document in the new order\n            if (data.nTr && cells[j] && columns[j].bVisible) {\n                data.nTr.appendChild(cells[j]);\n            }\n            // Update lookup index\n            if (cells[j] && cells[j]._DT_CellIndex) {\n                cells[j]._DT_CellIndex.column = j;\n            }\n        }\n    }\n    // Per column manipulation\n    for (i = 0; i < columns.length; i++) {\n        var column = columns[i];\n        // Data column sorting\n        for (j = 0; j < column.aDataSort.length; j++) {\n            column.aDataSort[j] = reverseIndexes[column.aDataSort[j]];\n        }\n        // Update the column indexes\n        column.idx = reverseIndexes[column.idx];\n        // Reorder the colgroup > col elements for the new order\n        if (column.bVisible) {\n            settings.colgroup.append(column.colEl);\n        }\n    }\n    // Header and footer\n    headerUpdate(settings.aoHeader, reverseIndexes, from, to);\n    headerUpdate(settings.aoFooter, reverseIndexes, from, to);\n    // Search - columns\n    arrayMove(settings.aoPreSearchCols, from[0], from.length, to);\n    // Ordering indexes update - note that the sort listener on the\n    // header works out the index to apply on each draw, so it doesn't\n    // need to be updated here.\n    orderingIndexes(reverseIndexes, settings.aaSorting);\n    if (Array.isArray(settings.aaSortingFixed)) {\n        orderingIndexes(reverseIndexes, settings.aaSortingFixed);\n    }\n    else if (settings.aaSortingFixed.pre) {\n        orderingIndexes(reverseIndexes, settings.aaSortingFixed.pre);\n    }\n    else if (settings.aaSortingFixed.post) {\n        orderingIndexes(reverseIndexes, settings.aaSortingFixed.pre);\n    }\n    settings.aLastSort.forEach(function (el) {\n        el.src = reverseIndexes[el.src];\n    });\n    // Fire an event so other plug-ins can update\n    dt.trigger('column-reorder', [\n        dt.settings()[0],\n        {\n            from: from,\n            to: to,\n            mapping: reverseIndexes\n        }\n    ]);\n}\n/**\n * Update the indexing for ordering arrays\n *\n * @param map Reverse index map\n * @param order Array to update\n */\nfunction orderingIndexes(map, order) {\n    // Can happen if the order was deleted from a saved state\n    if (!order) {\n        return;\n    }\n    for (var i = 0; i < order.length; i++) {\n        var el = order[i];\n        if (typeof el === 'number') {\n            // Just a number\n            order[i] = map[el];\n        }\n        else if ($.isPlainObject(el) && el.idx !== undefined) {\n            // New index in an object style\n            el.idx = map[el.idx];\n        }\n        else if (Array.isArray(el) && typeof el[0] === 'number') {\n            // The good old fixes length array\n            el[0] = map[el[0]];\n        }\n        // No need to update if in object + .name style\n    }\n}\n/**\n * Take an index array for the current positioned, reordered to what you want\n * them to be.\n *\n * @param dt DataTable being operated on - must be a single table instance\n * @param order Indexes from current order, positioned as you want them to be\n */\nfunction setOrder(dt, order, original) {\n    var changed = false;\n    var i;\n    if (order.length !== dt.columns().count()) {\n        dt.error('ColReorder - column count mismatch');\n        return;\n    }\n    // The order given is based on the original indexes, rather than the\n    // existing ones, so we need to translate from the original to current\n    // before then doing the order\n    if (original) {\n        order = transpose(dt, order, 'toCurrent');\n    }\n    // The API is array index as the desired position, but our algorithm below is\n    // for array index as the current position. So we need to invert for it to work.\n    var setOrder = invertKeyValues(order);\n    // Move columns, one by one with validation disabled!\n    for (i = 0; i < setOrder.length; i++) {\n        var currentIndex = setOrder.indexOf(i);\n        if (i !== currentIndex) {\n            // Reorder our switching error\n            arrayMove(setOrder, currentIndex, 1, i);\n            // Do the reorder\n            move(dt, [currentIndex], i);\n            changed = true;\n        }\n    }\n    // Reorder complete\n    if (changed) {\n        finalise(dt);\n    }\n}\n/**\n * Convert the DataTables header structure array into a 2D array where each\n * element has a reference to its TH/TD cell (regardless of spanning).\n *\n * @param structure Header / footer structure object\n * @returns 2D array of header cells\n */\nfunction structureFill(structure) {\n    var filledIn = [];\n    for (var row = 0; row < structure.length; row++) {\n        filledIn.push([]);\n        for (var col = 0; col < structure[row].length; col++) {\n            var cell = structure[row][col];\n            if (cell) {\n                for (var rowInner = 0; rowInner < cell.rowspan; rowInner++) {\n                    if (!filledIn[row + rowInner]) {\n                        filledIn[row + rowInner] = [];\n                    }\n                    for (var colInner = 0; colInner < cell.colspan; colInner++) {\n                        filledIn[row + rowInner][col + colInner] = cell.cell;\n                    }\n                }\n            }\n        }\n    }\n    return filledIn;\n}\n/**\n * Convert the index type\n *\n * @param dt DataTable to work on\n * @param idx Index to transform\n * @param dir Transform direction\n * @returns Converted number(s)\n */\nfunction transpose(dt, idx, dir) {\n    var order = dt.colReorder.order();\n    var columns = dt.settings()[0].aoColumns;\n    if (dir === 'toCurrent' || dir === 'fromOriginal') {\n        // Given an original index, want the current\n        return !Array.isArray(idx)\n            ? order.indexOf(idx)\n            : idx.map(function (index) {\n                return order.indexOf(index);\n            });\n    }\n    // Given a current index, want the original\n    return !Array.isArray(idx)\n        ? columns[idx]._crOriginalIdx\n        : idx.map(function (index) {\n            return columns[index]._crOriginalIdx;\n        });\n}\n/**\n * Validate that a requested move is okay. This includes bound checking\n * and that it won't split colspan'ed cells.\n *\n * @param table API instance\n * @param from Column indexes to move\n * @param to Destination index (starting if multiple)\n * @returns Validation result\n */\nfunction validateMove(table, from, to) {\n    var columns = table.columns().count();\n    // Sanity and bound checking\n    if (from[0] < to && to < from[from.length]) {\n        return false;\n    }\n    if (from[0] < 0 && from[from.length - 1] > columns) {\n        return false;\n    }\n    if (to < 0 && to > columns) {\n        return false;\n    }\n    // No change - it's valid\n    if (from.includes(to)) {\n        return true;\n    }\n    if (!validateStructureMove(table.table().header.structure(), from, to)) {\n        return false;\n    }\n    if (!validateStructureMove(table.table().footer.structure(), from, to)) {\n        return false;\n    }\n    return true;\n}\n/**\n * For a given structure check that the move is valid.\n * @param structure\n * @param from\n * @param to\n * @returns\n */\nfunction validateStructureMove(structure, from, to) {\n    var header = structureFill(structure);\n    var i;\n    // Shuffle the header cells around\n    for (i = 0; i < header.length; i++) {\n        arrayMove(header[i], from[0], from.length, to);\n    }\n    // Sanity check that the headers are next to each other\n    for (i = 0; i < header.length; i++) {\n        var seen = [];\n        for (var j = 0; j < header[i].length; j++) {\n            var cell = header[i][j];\n            if (!seen.includes(cell)) {\n                // Hasn't been seen before\n                seen.push(cell);\n            }\n            else if (seen[seen.length - 1] !== cell) {\n                // Has been seen before and is not the previous cell - validation failed\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n/**\n * This is one possible UI for column reordering in DataTables. In this case\n * columns are reordered by clicking and dragging a column header. It calculates\n * where columns can be dropped based on the column header used to start the drag\n * and then `colReorder.move()` method to alter the DataTable.\n */\nvar ColReorder = /** @class */ (function () {\n    function ColReorder(dt, opts) {\n        this.dom = {\n            drag: null\n        };\n        this.c = {\n            columns: null,\n            enable: null,\n            order: null\n        };\n        this.s = {\n            dropZones: [],\n            mouse: {\n                absLeft: -1,\n                offset: {\n                    x: -1,\n                    y: -1\n                },\n                start: {\n                    x: -1,\n                    y: -1\n                },\n                target: null,\n                targets: []\n            },\n            scrollInterval: null\n        };\n        var that = this;\n        var ctx = dt.settings()[0];\n        // Check if ColReorder already has been initialised on this DataTable - only\n        // one can exist.\n        if (ctx._colReorder) {\n            return;\n        }\n        dt.settings()[0]._colReorder = this;\n        this.dt = dt;\n        $.extend(this.c, ColReorder.defaults, opts);\n        init(dt);\n        dt.on('stateSaveParams', function (e, s, d) {\n            d.colReorder = getOrder(dt);\n        });\n        dt.on('destroy', function () {\n            dt.off('.colReorder');\n            dt.colReorder.reset();\n        });\n        // Initial ordering / state restoring\n        var loaded = dt.state.loaded();\n        var order = this.c.order;\n        if (loaded && loaded.colReorder) {\n            order = loaded.colReorder;\n        }\n        if (order) {\n            dt.ready(function () {\n                setOrder(dt, order, true);\n            });\n        }\n        dt.table()\n            .header.structure()\n            .forEach(function (row) {\n            for (var i = 0; i < row.length; i++) {\n                if (row[i] && row[i].cell) {\n                    that._addListener(row[i].cell);\n                }\n            }\n        });\n    }\n    ColReorder.prototype.disable = function () {\n        this.c.enable = false;\n        return this;\n    };\n    ColReorder.prototype.enable = function (flag) {\n        if (flag === void 0) { flag = true; }\n        if (flag === false) {\n            return this.disable();\n        }\n        this.c.enable = true;\n        return this;\n    };\n    /**\n     * Attach the mouse down listener to an element to start a column reorder action\n     *\n     * @param el\n     */\n    ColReorder.prototype._addListener = function (el) {\n        var that = this;\n        $(el)\n            .on('selectstart.colReorder', function () {\n            return false;\n        })\n            .on('mousedown.colReorder touchstart.colReorder', function (e) {\n            // Ignore middle and right click\n            if (e.type === 'mousedown' && e.which !== 1) {\n                return;\n            }\n            // Ignore if disabled\n            if (!that.c.enable) {\n                return;\n            }\n            that._mouseDown(e, this);\n        });\n    };\n    /**\n     * Create the element that is dragged around the page\n     */\n    ColReorder.prototype._createDragNode = function () {\n        var origCell = this.s.mouse.target;\n        var origTr = origCell.parent();\n        var origThead = origTr.parent();\n        var origTable = origThead.parent();\n        var cloneCell = origCell.clone();\n        // This is a slightly odd combination of jQuery and DOM, but it is the\n        // fastest and least resource intensive way I could think of cloning\n        // the table with just a single header cell in it.\n        this.dom.drag = $(origTable[0].cloneNode(false))\n            .addClass('dtcr-cloned')\n            .append($(origThead[0].cloneNode(false)).append($(origTr[0].cloneNode(false)).append(cloneCell[0])) // Not sure why  it doesn't want to append a jQuery node\n        )\n            .css({\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            width: $(origCell).outerWidth(),\n            height: $(origCell).outerHeight()\n        })\n            .appendTo('body');\n    };\n    /**\n     * Get cursor position regardless of mouse or touch input\n     *\n     * @param e Event\n     * @param prop Property name to get\n     * @returns Value - assuming a number here\n     */\n    ColReorder.prototype._cursorPosition = function (e, prop) {\n        return e.type.indexOf('touch') !== -1 ? e.originalEvent.touches[0][prop] : e[prop];\n    };\n    /**\n     * Cache values at start\n     *\n     * @param e Triggering event\n     * @param cell Cell that the action started on\n     * @returns\n     */\n    ColReorder.prototype._mouseDown = function (e, cell) {\n        var _this = this;\n        var target = $(e.target).closest('th, td');\n        var offset = target.offset();\n        var moveableColumns = this.dt.columns(this.c.columns).indexes().toArray();\n        var moveColumnIndexes = $(cell)\n            .attr('data-dt-column')\n            .split(',')\n            .map(function (val) {\n            return parseInt(val, 10);\n        });\n        // Don't do anything for columns which are not selected as moveable\n        for (var j = 0; j < moveColumnIndexes.length; j++) {\n            if (!moveableColumns.includes(moveColumnIndexes[j])) {\n                return false;\n            }\n        }\n        this.s.mouse.start.x = this._cursorPosition(e, 'pageX');\n        this.s.mouse.start.y = this._cursorPosition(e, 'pageY');\n        this.s.mouse.offset.x = this._cursorPosition(e, 'pageX') - offset.left;\n        this.s.mouse.offset.y = this._cursorPosition(e, 'pageY') - offset.top;\n        this.s.mouse.target = target;\n        this.s.mouse.targets = moveColumnIndexes;\n        // Classes to highlight the columns being moved\n        for (var i = 0; i < moveColumnIndexes.length; i++) {\n            var cells = this.dt\n                .cells(null, moveColumnIndexes[i], { page: 'current' })\n                .nodes()\n                .to$();\n            var klass = 'dtcr-moving';\n            if (i === 0) {\n                klass += ' dtcr-moving-first';\n            }\n            if (i === moveColumnIndexes.length - 1) {\n                klass += ' dtcr-moving-last';\n            }\n            cells.addClass(klass);\n        }\n        this._regions(moveColumnIndexes);\n        this._scrollRegions();\n        /* Add event handlers to the document */\n        $(document)\n            .on('mousemove.colReorder touchmove.colReorder', function (e) {\n            _this._mouseMove(e);\n        })\n            .on('mouseup.colReorder touchend.colReorder', function (e) {\n            _this._mouseUp(e);\n        });\n    };\n    ColReorder.prototype._mouseMove = function (e) {\n        if (this.dom.drag === null) {\n            // Only create the drag element if the mouse has moved a specific distance from the start\n            // point - this allows the user to make small mouse movements when sorting and not have a\n            // possibly confusing drag element showing up\n            if (Math.pow(Math.pow(this._cursorPosition(e, 'pageX') - this.s.mouse.start.x, 2) +\n                Math.pow(this._cursorPosition(e, 'pageY') - this.s.mouse.start.y, 2), 0.5) < 5) {\n                return;\n            }\n            $(document.body).addClass('dtcr-dragging');\n            this._createDragNode();\n        }\n        // Position the element - we respect where in the element the click occurred\n        this.dom.drag.css({\n            left: this._cursorPosition(e, 'pageX') - this.s.mouse.offset.x,\n            top: this._cursorPosition(e, 'pageY') - this.s.mouse.offset.y\n        });\n        // Find cursor's left position relative to the table\n        var tableOffset = $(this.dt.table().node()).offset().left;\n        var cursorMouseLeft = this._cursorPosition(e, 'pageX') - tableOffset;\n        var dropZone = this.s.dropZones.find(function (zone) {\n            if (zone.left <= cursorMouseLeft && cursorMouseLeft <= zone.left + zone.width) {\n                return true;\n            }\n            return false;\n        });\n        this.s.mouse.absLeft = this._cursorPosition(e, 'pageX');\n        if (!dropZone) {\n            return;\n        }\n        if (!dropZone.self) {\n            this._move(dropZone, cursorMouseLeft);\n        }\n    };\n    ColReorder.prototype._mouseUp = function (e) {\n        $(document).off('.colReorder');\n        $(document.body).removeClass('dtcr-dragging');\n        if (this.dom.drag) {\n            this.dom.drag.remove();\n            this.dom.drag = null;\n        }\n        if (this.s.scrollInterval) {\n            clearInterval(this.s.scrollInterval);\n        }\n        this.dt.cells('.dtcr-moving').nodes().to$().removeClass('dtcr-moving dtcr-moving-first dtcr-moving-last');\n    };\n    /**\n     * Shift columns around\n     *\n     * @param dropZone Where to move to\n     * @param cursorMouseLeft Cursor position, relative to the left of the table\n     */\n    ColReorder.prototype._move = function (dropZone, cursorMouseLeft) {\n        var that = this;\n        this.dt.colReorder.move(this.s.mouse.targets, dropZone.colIdx);\n        // Update the targets\n        this.s.mouse.targets = $(this.s.mouse.target)\n            .attr('data-dt-column')\n            .split(',')\n            .map(function (val) {\n            return parseInt(val, 10);\n        });\n        this._regions(this.s.mouse.targets);\n        var visibleTargets = this.s.mouse.targets.filter(function (val) {\n            return that.dt.column(val).visible();\n        });\n        // If the column being moved is smaller than the column it is replacing,\n        // the drop zones might need a correction to allow for this since, otherwise\n        // we might immediately be changing the column order as soon as it was placed.\n        // Find the drop zone for the first in the list of targets - is its\n        // left greater than the mouse position. If so, it needs correcting\n        var dz = this.s.dropZones.find(function (zone) {\n            return zone.colIdx === visibleTargets[0];\n        });\n        var dzIdx = this.s.dropZones.indexOf(dz);\n        if (dz.left > cursorMouseLeft) {\n            var previousDiff = dz.left - cursorMouseLeft;\n            var previousDz = this.s.dropZones[dzIdx - 1];\n            dz.left -= previousDiff;\n            dz.width += previousDiff;\n            if (previousDz) {\n                previousDz.width -= previousDiff;\n            }\n        }\n        // And for the last in the list\n        dz = this.s.dropZones.find(function (zone) {\n            return zone.colIdx === visibleTargets[visibleTargets.length - 1];\n        });\n        if (dz.left + dz.width < cursorMouseLeft) {\n            var nextDiff = cursorMouseLeft - (dz.left + dz.width);\n            var nextDz = this.s.dropZones[dzIdx + 1];\n            dz.width += nextDiff;\n            if (nextDz) {\n                nextDz.left += nextDiff;\n                nextDz.width -= nextDiff;\n            }\n        }\n    };\n    /**\n     * Determine the boundaries for where drops can happen and where they would\n     * insert into.\n     */\n    ColReorder.prototype._regions = function (moveColumns) {\n        var that = this;\n        var dropZones = [];\n        var totalWidth = 0;\n        var negativeCorrect = 0;\n        var allowedColumns = this.dt.columns(this.c.columns).indexes().toArray();\n        var widths = this.dt.columns().widths();\n        // Each column is a drop zone\n        this.dt.columns().every(function (colIdx, tabIdx, i) {\n            if (!this.visible()) {\n                return;\n            }\n            var columnWidth = widths[colIdx];\n            // Check that we are allowed to move into this column - if not, need\n            // to offset the widths\n            if (!allowedColumns.includes(colIdx)) {\n                totalWidth += columnWidth;\n                return;\n            }\n            var valid = validateMove(that.dt, moveColumns, colIdx);\n            if (valid) {\n                // New drop zone. Note that it might have it's offset moved\n                // by the final condition in this logic set\n                dropZones.push({\n                    colIdx: colIdx,\n                    left: totalWidth - negativeCorrect,\n                    self: moveColumns[0] <= colIdx && colIdx <= moveColumns[moveColumns.length - 1],\n                    width: columnWidth + negativeCorrect\n                });\n            }\n            else if (colIdx < moveColumns[0]) {\n                // Not valid and before the column(s) to be moved - the drop\n                // zone for the previous valid drop point is extended\n                if (dropZones.length) {\n                    dropZones[dropZones.length - 1].width += columnWidth;\n                }\n            }\n            else if (colIdx > moveColumns[moveColumns.length - 1]) {\n                // Not valid and after the column(s) to be moved - the next\n                // drop zone to be created will be extended\n                negativeCorrect += columnWidth;\n            }\n            totalWidth += columnWidth;\n        });\n        this.s.dropZones = dropZones;\n        // this._drawDropZones();\n    };\n    /**\n     * Check if the table is scrolling or not. It is it the `table` isn't the same for\n     * the header and body parents.\n     *\n     * @returns\n     */\n    ColReorder.prototype._isScrolling = function () {\n        return this.dt.table().body().parentNode !== this.dt.table().header().parentNode;\n    };\n    /**\n     * Set an interval clock that will check to see if the scrolling of the table body should be moved\n     * as the mouse moves on the scroll (allowing a drag and drop to columns which aren't yet visible)\n     */\n    ColReorder.prototype._scrollRegions = function () {\n        if (!this._isScrolling()) {\n            // Not scrolling - nothing to do\n            return;\n        }\n        var that = this;\n        var tableLeft = $(this.dt.table().container()).position().left;\n        var tableWidth = $(this.dt.table().container()).outerWidth();\n        var mouseBuffer = 75;\n        var scrollContainer = this.dt.table().body().parentElement.parentElement;\n        this.s.scrollInterval = setInterval(function () {\n            var mouseLeft = that.s.mouse.absLeft;\n            if (mouseLeft < tableLeft + mouseBuffer && scrollContainer.scrollLeft) {\n                scrollContainer.scrollLeft -= 5;\n            }\n            else if (mouseLeft > tableLeft + tableWidth - mouseBuffer &&\n                scrollContainer.scrollLeft < scrollContainer.scrollWidth) {\n                scrollContainer.scrollLeft += 5;\n            }\n        }, 25);\n    };\n    // This is handy for debugging where the drop zones actually are!\n    // private _drawDropZones () {\n    // \tlet dropZones = this.s.dropZones;\n    // \t$('div.allan').remove();\n    // \tfor (let i=0 ; i<dropZones.length ; i++) {\n    // \t\tlet zone = dropZones[i];\n    // \t\t$(this.dt.table().container()).append(\n    // \t\t\t$('<div>')\n    // \t\t\t\t.addClass('allan')\n    // \t\t\t\t.css({\n    // \t\t\t\t\tposition: 'absolute',\n    // \t\t\t\t\ttop: 0,\n    // \t\t\t\t\twidth: zone.width - 4,\n    // \t\t\t\t\theight: 20,\n    // \t\t\t\t\tleft: zone.left + 2,\n    // \t\t\t\t\tborder: '1px solid red',\n    // \t\t\t\t})\n    // \t\t);\n    // \t}\n    // }\n    ColReorder.defaults = {\n        columns: '',\n        enable: true,\n        order: null\n    };\n    ColReorder.version = '2.0.4';\n    return ColReorder;\n}());\n\n/*! ColReorder 2.0.4\n * © SpryMedia Ltd - datatables.net/license\n */\n/**\n * @summary     ColReorder\n * @description Provide the ability to reorder columns in a DataTable\n * @version     2.0.4\n * @author      SpryMedia Ltd\n * @contact     datatables.net\n * @copyright   SpryMedia Ltd.\n *\n * This source file is free software, available under the following license:\n *   MIT license - http://datatables.net/license/mit\n *\n * This source file is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.\n *\n * For details please refer to: http://www.datatables.net\n */\n // declare var DataTable: any;\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * UI interaction class\n */\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * DataTables API integration\n */\n/** Enable mouse column reordering */\nDataTable.Api.register('colReorder.enable()', function (flag) {\n    return this.iterator('table', function (ctx) {\n        if (ctx._colReorder) {\n            ctx._colReorder.enable(flag);\n        }\n    });\n});\n/** Disable mouse column reordering */\nDataTable.Api.register('colReorder.disable()', function () {\n    return this.iterator('table', function (ctx) {\n        if (ctx._colReorder) {\n            ctx._colReorder.disable();\n        }\n    });\n});\n/**\n * Change the ordering of the columns in the DataTable.\n */\nDataTable.Api.register('colReorder.move()', function (from, to) {\n    init(this);\n    if (!Array.isArray(from)) {\n        from = [from];\n    }\n    if (!validateMove(this, from, to)) {\n        this.error('ColReorder - invalid move');\n        return this;\n    }\n    return this.tables().every(function () {\n        move(this, from, to);\n        finalise(this);\n    });\n});\nDataTable.Api.register('colReorder.order()', function (set, original) {\n    init(this);\n    if (!set) {\n        return this.context.length ? getOrder(this) : null;\n    }\n    return this.tables().every(function () {\n        setOrder(this, set, original);\n    });\n});\nDataTable.Api.register('colReorder.reset()', function () {\n    init(this);\n    return this.tables().every(function () {\n        var order = this.columns()\n            .every(function (i) {\n            return i;\n        })\n            .flatten()\n            .toArray();\n        setOrder(this, order, true);\n    });\n});\nDataTable.Api.register('colReorder.transpose()', function (idx, dir) {\n    init(this);\n    if (!dir) {\n        dir = 'toCurrent';\n    }\n    return transpose(this, idx, dir);\n});\nDataTable.ColReorder = ColReorder;\n// Called when DataTables is going to load a state. That might be\n// before the table is ready (state saving) or after (state restoring).\n// Also note that it happens _before_ preInit (below).\n$(document).on('stateLoadInit.dt', function (e, settings, state) {\n    if (e.namespace !== 'dt') {\n        return;\n    }\n    var dt = new DataTable.Api(settings);\n    if (state.colReorder) {\n        if (dt.ready()) {\n            // Table is fully loaded - do the column reordering here\n            // so that the stored indexes are in the correct place\n            // e.g. column visibility\n            setOrder(dt, state.colReorder, true);\n        }\n        else {\n            // If the table is not ready, column reordering is done\n            // after it becomes fully ready. That means that saved\n            // column indexes need to be updated for where those columns\n            // currently are. Any properties which refer to column indexes\n            // would need to be updated here.\n            // State's ordering indexes\n            orderingIndexes(state.colReorder, state.order);\n            // State's columns array - sort by restore index\n            if (state.columns) {\n                for (var i = 0; i < state.columns.length; i++) {\n                    state.columns[i]._cr_sort = state.colReorder[i];\n                }\n                state.columns.sort(function (a, b) {\n                    return a._cr_sort - b._cr_sort;\n                });\n            }\n        }\n    }\n});\n$(document).on('preInit.dt', function (e, settings) {\n    if (e.namespace !== 'dt') {\n        return;\n    }\n    var init = settings.oInit.colReorder;\n    var defaults = DataTable.defaults.colReorder;\n    if (init || defaults) {\n        var opts = $.extend({}, defaults, init);\n        if (init !== false) {\n            var dt = new DataTable.Api(settings);\n            new ColReorder(dt, opts);\n        }\n    }\n});\n\n\nreturn DataTable;\n}));\n"],"names":["factory","define","amd","$","window","document","exports","jq","require","cjsRequires","root","fn","dataTable","module","jQuery","DataTable","arrayMove","arr","from","count","to","movers","splice","unshift","apply","finalise","dt","rows","invalidate","column","visible","columns","adjust","order","colReorder","trigger","mapping","invertKeyValues","getOrder","settings","aoColumns","map","col","_crOriginalIdx","headerUpdate","structure","done","i","length","headerRow","j","cell","includes","mapped","getAttribute","split","idx","join","setAttribute","push","init","api","iterator","s","undefined","result","move","newOrder","reverseIndexes","aoData","data","cells","anCells","nTr","bVisible","appendChild","_DT_CellIndex","aDataSort","colgroup","append","colEl","aoHeader","aoFooter","aoPreSearchCols","orderingIndexes","aaSorting","Array","isArray","aaSortingFixed","pre","post","aLastSort","forEach","el","src","isPlainObject","setOrder","original","changed","transpose","currentIndex","indexOf","error","dir","index","validateMove","table","validateStructureMove","header","footer","filledIn","row","rowInner","rowspan","colInner","colspan","structureFill","seen","ColReorder","opts","dom","drag","c","enable","dropZones","mouse","absLeft","offset","x","y","start","target","targets","scrollInterval","that","this","_colReorder","extend","defaults","on","e","d","off","reset","loaded","state","ready","_addListener","prototype","disable","flag","type","which","_mouseDown","_createDragNode","origCell","origTr","parent","origThead","origTable","cloneCell","clone","cloneNode","addClass","css","position","top","left","width","outerWidth","height","outerHeight","appendTo","_cursorPosition","prop","originalEvent","touches","_this","closest","moveableColumns","indexes","toArray","moveColumnIndexes","attr","val","parseInt","page","nodes","to$","klass","_regions","_scrollRegions","_mouseMove","_mouseUp","Math","pow","body","tableOffset","node","cursorMouseLeft","dropZone","find","zone","self","_move","removeClass","remove","clearInterval","colIdx","visibleTargets","filter","dz","dzIdx","previousDiff","previousDz","nextDiff","nextDz","moveColumns","totalWidth","negativeCorrect","allowedColumns","widths","every","tabIdx","columnWidth","_isScrolling","parentNode","tableLeft","container","tableWidth","scrollContainer","parentElement","setInterval","mouseLeft","scrollLeft","scrollWidth","version","Api","register","ctx","tables","set","context","flatten","namespace","_cr_sort","sort","a","b","oInit"],"mappings":"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"}